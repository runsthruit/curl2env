#! /bin/bash

function curl_env ()
#
#
#
{

	#
	__bash_function_init_opts=(
		help
		manual
		out
		curl_{help,manual}
	)
	__bash_function_init_locv_strings=(
		CHR_{ESC,DBQ,SGQ}
	)
	__bash_function_init_locv_arrays=(
		WVARS
		CMD{,_{RAW,DBG}}
	)
	__bash_function_init_glbv_strings=()
	__bash_function_init_glbv_arrays=(
		curl_env_{dbg,ext,hin,hdr,out,err,stt}
	)
	: BASH_FUNCTION_INIT SOURCE; eval "$( bash_function_init || echo return 1 )"

	#
	[ "${OPT_help:-0}" -eq 0 -a "${OPT_manual:-0}" -eq 0 ] \
	|| {
		cat - 1>&2 <<-'EOF'

		DESCRIPTION::

		  This function sets global shell variables, and therefore should not be run in a subshell.

		  Instead, you may do something like this..

		    { TMP="$( curl_env icanhazip.com )"; echo "${TMP}" | __YOUR_PARSER__; }

		  If you DO pipe this command, it will echo its output for use on stdin to other commands.

		    { curl_env icanhazip.com | __YOUR_PARSER__; }

		OPTIONS::

		  To produce debug output..
		  
		    --debug
		    
		  Or set explicitely to a certain level..
		  
		    --debug=[0-9]

		  Or, use the debug environment variable..

		    export DEBUG_CURL_ENV=[0-9]

		  To view the curl help or manual, provide these options..
		
		    --curl_help

		    --curl_manual

		NOTES::
		
		  Only run a single call at a time. ( For now.. =] )

		EOF
		return 0
	}
	[ "${OPT_curl_help}" -eq 0 ] || { curl --help; return 0; }
	[ "${OPT_curl_manual}" -eq 0 ] || { curl --manual; return 0; }

	#
	CHR_ESC="\\"
	CHR_DBQ="\""
	CHR_SGQ="'"
	WVARS=(
		http_code
		url_effective redirect_url
		http_connect
		time_total
		time_namelookup time_connect time_appconnect
		time_pretransfer time_redirect time_starttransfer
		size_download size_upload size_header size_request
		speed_download speed_upload
		content_type
		num_connects num_redirects
		ftp_entry_path ssl_verify_result
	)

	#
	CMD_RAW=(
		curl
		-vs
		${ARGS[@]:+"${ARGS[@]}"}
	)

	for VAR in curl_env_{dbg,ext,hin,hdr,out,err,stt}
	do
		eval "${VAR}=()"
	done

	[ "${DBG:-0}" -lt 9 ] || echo 1>&2
	for ENT in "${CMD_RAW[@]}"
	do
		TMP=
		[ "${DBG:-0}" -lt 9 ] || \
		printf "{ %q }\n" "${ENT}" 1>&2
		printf -v ENT "%q" "${ENT}"
		CMD[${#CMD[@]}]="${ENT}"
		[[ "${ENT}" =~ \\ && ! "${ENT}" =~ ^"$'" ]] || \
		{ CMD_DBG[${#CMD_DBG[@]}]="${ENT}"; continue; }
		while [[ "${ENT}" =~ ([^\\]*)([\\])(.)(.*) ]]
		do
			TMP="${TMP}${BASH_REMATCH[1]}"
			[ "${BASH_REMATCH[3]}" != "'" ] || \
			TMP="${TMP}\\"
			TMP="${TMP}${BASH_REMATCH[3]}"
			ENT="${BASH_REMATCH[4]}"
			[ "${DBG:-0}" -lt 9 ] || \
			printf "( %s ) ( %s )\n" "${ENT}" "${TMP}" 1>&2
		done
		[ "${DBG:-0}" -lt 9 ] || \
		printf "{ %s }\n" "'${TMP}${ENT}'" 1>&2
		CMD_DBG[${#CMD_DBG[@]}]="'${TMP}${ENT}'"
	done

	[ "${DBG:-0}" -lt 9 ] || echo 1>&2
	[ "${DBG:-0}" -lt 1 ] || \
	echo "+ ${CMD_DBG[*]}" 1>&2
	[ "${DBG:-0}" -lt 8 ] || echo 1>&2

	TMP="$(
		IFS="${NLN}"
		{
			{ [ -t 0 ] && cat /dev/null || cat -; } |
			tee >( { [ "${DBG:-0}" -lt 8 ] && cat - >/dev/null || { sed "s/^/0 /" | cat -vet; } 1>&2; } ) |
			{
				eval "${CMD[@]}" \
					-w "\"$( printf "2 = %s=%%{%s}\\\n" $( for I in "${WVARS[@]}"; do echo "${I}"; echo "${I}"; done ) )\"" \
					-o >( sed "s=^=1 . =" ) \
					2> >( sed "s=^=2 =" 1>&2 )
			} 2>&1
			echo "3 ${?}" 1>&2
		} 2>&1 |
		tee >( { [ "${DBG:-0}" -lt 8 ] && cat - >/dev/null || cat -vet - 1>&2; } ) |
		{
			while read -r ENT
			do
				[[ "${ENT}" =~ ^([123])(.?)(.?)(.?)(.*)$ ]] || :
				case "${BASH_REMATCH[1]:-}" in
				( 3 ) curl_env_ext[${#curl_env_ext[@]}]="${ENT:2:1}";;
				( 1 ) {
					case "${BASH_REMATCH[3]:-}" in
					( "." ) curl_env_out[${#curl_env_out[@]}]="${ENT:4}";;
					esac
				};;
				( 2 ) {
					ENT="${ENT%${CRT}}"
					case "${BASH_REMATCH[3]:-}" in
					( "*" | " " | "${TAB}" ) {
						[ "${ENT:4}" == "" ] \
						|| curl_env_dbg[${#curl_env_dbg[@]}]="${ENT:4}"
					};;
					( "=" ) {
						[ "${ENT:4}" == "" ] \
						|| curl_env_stt[${#curl_env_stt[@]}]="${ENT:4}"
					};;
					( "<" ) {
						[ "${ENT:4}" == "" ] \
						|| curl_env_hdr[${#curl_env_hdr[@]}]="${ENT:4}"
					};;
					( ">" ) {
						[ "${ENT:4}" == "" ] \
						|| curl_env_hin[${#curl_env_hin[@]}]="${ENT:4}"
					};;
					( "{" | "}" ) :;;
					( * ) {
						curl_env_err[${#curl_env_err[@]}]="${ENT:2}"
						echo "? ${ENT:2}" 1>&2
					};;
					esac
				};;
				esac
			done
			for VAR in curl_env_{dbg,ext,hin,hdr,out,err,stt}
			do
				VAL="$( declare -p ${VAR} )"
				VAL="${VAL#*\'}"
				VAL="${VAL%\'*}"
				VAL="${VAL//\'\\\'\'/${CHR_SGQ}}"
				echo "${VAR}=${VAL}"
			done
		}
	)"

	eval "${TMP}"

	[ "${DBG:-0}" -gt 7 ] || {
	[ "${DBG:-0}" -lt 4 ] || { echo; printf "* %s\n" "${curl_env_dbg[@]}"; } 1>&2
	[ "${DBG:-0}" -lt 5 ] || { printf "! %s\n" "${curl_env_ext[@]}"; } 1>&2
	[ "${DBG:-0}" -lt 6 ] || { echo; printf "= %s\n" "${curl_env_stt[@]}"; } 1>&2
	[ "${DBG:-0}" -lt 3 ] \
	&& { echo "${curl_env_hdr[0]:-ERR_NO_HEADERS}"; } 1>&2 \
	|| {
		echo; printf "> %s\n" "${curl_env_hin[@]}"
		echo; printf "< %s\n" "${curl_env_hdr[@]}"
	} 1>&2
	[ "${DBG:-0}" -lt 5 -o "${#curl_env_err[*]}" -eq 0 ] \
	|| { echo; printf "? %s\n" "${curl_env_err[@]}"; } 1>&2
	}
	[ "${DBG:-0}" -lt 3 ] || { echo; } 1>&2
	[ "${DBG:-0}" -lt 2 -a -t 1 -a "${OPT_out}" -eq 0 ] || printf "%s\n" "${curl_env_out[@]}"

	return ${curl_env_ext[0]:-100}

}
