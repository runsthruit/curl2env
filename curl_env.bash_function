#! /bin/bash

function curl_env ()
#
#
#
{

	#
	__bash_function_init_opts=(
		help
		manual
		out
		curl_{help,manual}
	)
	__bash_function_init_locv_strings=(
		CHR_{ESC,DBQ,SGQ}
		RGX_{TIME,INFO,XMIT}
	)
	__bash_function_init_locv_arrays=(
		WVARS
		CMD{,_{RAW,DBG}}
		curl_env_tmp_{dbg,ext,hin,hdr,out,err,stt,ssl}
	)
	__bash_function_init_glbv_strings=()
	__bash_function_init_glbv_arrays=(
		curl_env_{dbg,ext,hin,hdr,out,err,stt,ssl}
	)
	: BASH_FUNCTION_INIT SOURCE; eval "$( bash_function_init || echo return 1 )"

	#
	[ "${OPT_help:-0}" -eq 0 -a "${OPT_manual:-0}" -eq 0 ] \
	|| {
		cat - 1>&2 <<-'EOF'

		DESCRIPTION::

		  This function sets global shell variables, and therefore should not be run in a subshell.

		  Instead, you may do something like this..

		    { TMP="$( curl_env icanhazip.com )"; echo "${TMP}" | __YOUR_PARSER__; }

		  If you DO pipe this command, it will echo its output for use on stdin to other commands.

		    { curl_env icanhazip.com | __YOUR_PARSER__; }

		OPTIONS::

		  To produce debug output..
		  
		    --debug
		    
		  Or set explicitely to a certain level..
		  
		    --debug=[0-9]

		  Or, use the debug environment variable..

		    export DEBUG_CURL_ENV=[0-9]

		  To view the curl help or manual, provide these options..
		
		    --curl_help

		    --curl_manual

		NOTES::
		
		  Only run a single call at a time. ( For now.. =] )

		EOF
		return 0
	}
	[ "${OPT_curl_help}" -eq 0 ] || { curl --help; return 0; }
	[ "${OPT_curl_manual}" -eq 0 ] || { curl --manual; return 0; }

	#
	WVARS=(
		http_code
		url_effective redirect_url
		http_connect
		time_total
		time_namelookup time_connect time_appconnect
		time_pretransfer time_redirect time_starttransfer
		size_download size_upload size_header size_request
		speed_download speed_upload
		content_type
		num_connects num_redirects
		ftp_entry_path ssl_verify_result
	)
	CHR_ESC="\\"
	CHR_DBQ="\""
	CHR_SGQ="'"
	RGX_TIME="^([0-9]{2,2}:[0-9]{2,2}:[0-9]{2,2}\.[0-9]+)"
	RGX_INFO="${RGX_TIME} (<=|==|=>) (.*[^[:blank:]].*)"
	RGX_XMIT="${RGX_TIME} (<=|=>) ((Send|Recv) (header|data|SSL data)), ([0-9]+).*"

	#
	CMD_RAW=(
		${ARGS[@]:+"${ARGS[@]}"}
	)

	for VAR in curl_env_{dbg,ext,hin,hdr,out,err,stt}
	do
		eval "${VAR}=()"
	done

	[ "${DBG:-0}" -lt 9 ] || echo 1>&2
	for ENT in "${CMD_RAW[@]}"
	do
		TMP=
		[ "${DBG:-0}" -lt 9 ] || \
		printf "{ %q }\n" "${ENT}" 1>&2
		printf -v ENT "%q" "${ENT}"
		CMD[${#CMD[@]}]="${ENT}"
		[[ "${ENT}" =~ \\ && ! "${ENT}" =~ ^"$'" ]] || \
		{ CMD_DBG[${#CMD_DBG[@]}]="${ENT}"; continue; }
		while [[ "${ENT}" =~ ([^\\]*)([\\])(.)(.*) ]]
		do
			TMP="${TMP}${BASH_REMATCH[1]}"
			[ "${BASH_REMATCH[3]}" != "'" ] || \
			TMP="${TMP}\\"
			TMP="${TMP}${BASH_REMATCH[3]}"
			ENT="${BASH_REMATCH[4]}"
			[ "${DBG:-0}" -lt 9 ] || \
			printf "( %s ) ( %s )\n" "${ENT}" "${TMP}" 1>&2
		done
		[ "${DBG:-0}" -lt 9 ] || \
		printf "{ %s }\n" "'${TMP}${ENT}'" 1>&2
		CMD_DBG[${#CMD_DBG[@]}]="'${TMP}${ENT}'"
	done

	[ "${DBG:-0}" -lt 9 ] || echo 1>&2
	[ "${DBG:-0}" -lt 1 ] || \
	echo "+ curl ${CMD_DBG[*]}" 1>&2
	[ "${DBG:-0}" -lt 8 ] || echo 1>&2

	TMP="$(
		IFS="${CRT}${NLN}"
		{ [ -t 0 ] && cat /dev/null || cat -; } |
		{
			eval curl \
				-w "\"$(
					printf \
						"CURL_ENV_STT:%s=%%{%s}\\\n" \
						$( for I in "${WVARS[@]}"; do echo "${I}"; echo "${I}"; done )
				)\"" \
				-o /dev/null \
				--trace-time \
				--trace - \
				"${CMD[@]}"
			echo "CURL_ENV_EXT:${?}"
		} |
		{
			while read -r ENT
			do
				[ -n "${ENT}" ] || continue
				if [[ "${ENT}" =~ ${RGX_INFO} ]]
				then
					STG=DBG; CNT=.
				elif [[ "${ENT}" =~ ^CURL_ENV_STT:(.*) ]]
				then
					STG=STT; CNT=.
				elif [[ "${ENT}" =~ ^CURL_ENV_EXT:(.*) ]]
				then
					STG=EXT; CNT=.
				fi
				[ "${DBG:-0}" -lt 8 ] || \
				printf "%-15s  %6s  %q\n" "${STG}" "${CNT}" "${ENT}" 1>&2
				case "${STG}" in
				( DBG ) {
					eval "curl_env_tmp_dbg[0]=\"\${curl_env_tmp_dbg[0]}\${curl_env_tmp_dbg[0]:+\${NLN}}${ENT}\""
				};;
				( EXT ) {
					eval "curl_env_tmp_ext[0]=\"\${curl_env_tmp_ext[0]}\${curl_env_tmp_ext[0]:+\${NLN}}${BASH_REMATCH[1]}\""
				};;
				( STT ) {
					eval "curl_env_tmp_stt[0]=\"\${curl_env_tmp_stt[0]}\${curl_env_tmp_stt[0]:+\${NLN}}${BASH_REMATCH[1]}\""
				};;
				( curl_env_tmp_* ) {
					[[ "${ENT}" =~ ^[0-9a-f]{4,4}:([ 0-9a-f]{48,48}) ]]
					[[ "${BASH_REMATCH[1]}" =~ ([ 0-9a-f]*[0-9a-f]) ]]
					TMP="${BASH_REMATCH[1]}"
					TMP="${STG}[0]=\"\${${STG}[0]}\"\$'${TMP// /\\x}'"
					eval "${TMP}"
				};;
				esac
				if [[ "${ENT}" =~ ${RGX_XMIT} ]]
				then
					case "${BASH_REMATCH[3]}" in
					( "Recv header" )	STG=curl_env_tmp_hdr;;
					( "Send header" )	STG=curl_env_tmp_hin;;
					( "Recv data" )		STG=curl_env_tmp_out;;
					( "Send data" )		STG=curl_env_tmp_inp;;
					( "Recv SSL data" )	STG=curl_env_tmp_ssl;;
					( "Send SSL data" )	STG=curl_env_tmp_ssl;;
					esac
					CNT="${BASH_REMATCH[6]}"
				fi
			done
			unset curl_env_tmp_ssl
			declare -p ${!curl_env_tmp_*}
		}
		IFS="${IFS_BAK:-$' \t\n'}"
	)"

	eval "${TMP}"

	curl_env_tmp_ssl[0]=

	for ENT in {dbg,ext,hin,hdr,out,err,stt,ssl}
	do
		eval "curl_env_${ENT}=( \"\${curl_env_tmp_${ENT}[@]}\" )"
	done
	unset ${!curl_env_tmp_*}

	[[ ! "${curl_env_hdr[0]}" =~ (Transfer-Encoding: chunked) ]] || {
		TMP=
		while [[ "${curl_env_out[0]}" =~ ^(.*${CRT}${NLN})([0-9a-fA-F]{1,}${CRT}${NLN})(.*)(${CRT}${NLN})$ ]]
		do
			TMP="${BASH_REMATCH[3]}${TMP}"
			curl_env_out[0]="${BASH_REMATCH[1]}"
		done
		[[ "${curl_env_out[0]}" =~ ^([0-9a-fA-F]{1,}${CRT}${NLN})(.*)(${CRT}${NLN})$ ]]
		curl_env_out[0]="${BASH_REMATCH[2]}${TMP}"
	}

	curl_env_hdr[0]="${curl_env_hdr[0]//${CRT}${NLN}/${NLN}}"
	curl_env_hin[0]="${curl_env_hin[0]//${CRT}${NLN}/${NLN}}"
	[[ "${curl_env_hdr[0]}" =~ (.*[^${NLN}])[${NLN}]+$ ]] && curl_env_hdr[0]="${BASH_REMATCH[1]}"
	[[ "${curl_env_hin[0]}" =~ (.*[^${NLN}])[${NLN}]+$ ]] && curl_env_hin[0]="${BASH_REMATCH[1]}"

	[ "${DBG:-0}" -gt 7 ] || {
		[ "${DBG:-0}" -lt 4 ] || { echo; printf "* %s\n" "${curl_env_dbg[0]//${NLN}/${NLN}* }"; } 1>&2
		[ "${DBG:-0}" -lt 5 ] || { printf "! %s\n" "${curl_env_ext[0]//${NLN}/${NLN}! }"; } 1>&2
		[ "${DBG:-0}" -lt 6 ] || { echo; printf "= %s\n" "${curl_env_stt[0]//${NLN}/${NLN}= }"; } 1>&2
		[ "${DBG:-0}" -lt 3 ] \
		&& { TMP="${curl_env_hdr[0]%%${NLN}*}"; printf "%s\n" "${TMP:-ERR_NO_HEADERS}"; } 1>&2 \
		|| {
			echo; printf "> %s\n" "${curl_env_hin[0]//${NLN}/${NLN}> }"
			echo; printf "< %s\n" "${curl_env_hdr[0]//${NLN}/${NLN}< }"
		} 1>&2
		[ "${DBG:-0}" -lt 5 -o "${#curl_env_err[0]}" -eq 0 ] \
		|| { echo; printf "? %s\n" "${curl_env_err[0]//${NLN}/${NLN}? }"; } 1>&2
	}
	[ "${DBG:-0}" -lt 3 ] || { echo; } 1>&2
	[ "${DBG:-0}" -lt 2 -a -t 1 -a "${OPT_out}" -eq 0 ] || printf "%s" "${curl_env_out[0]}"

	return ${curl_env_ext[0]:-100}

}
