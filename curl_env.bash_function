#! /bin/bash

function curl_env ()
#
#
#
{

	#
	__bash_function_init_opts=(
		help
		manual
		out
		curl_{help,manual}
	)
	__bash_function_init_locv_strings=(
		CHR_{ESC,DBQ,SGQ}
		RGX_{TIME,INFO,XMIT}
	)
	__bash_function_init_locv_arrays=(
		WVARS
		CMD{,_{RAW,DBG}}
	)
	__bash_function_init_glbv_strings=()
	__bash_function_init_glbv_arrays=(
		curl_env_dbg
		curl_env_ext
		curl_env_hin
		curl_env_hdr
		curl_env_out
		curl_env_err
		curl_env_stt
	)
	: BASH_FUNCTION_INIT SOURCE; eval "$( bash_function_init || echo return 1 )"

	#
	[ "${OPT_help:-0}" -eq 0 -a "${OPT_manual:-0}" -eq 0 ] \
	|| {
		cat - 1>&2 <<-'EOF'

		DESCRIPTION::

		  This function sets global shell variables, and therefore should not be run in a subshell.

		  Instead, you may do something like this..

		    { TMP="$( curl_env icanhazip.com )"; echo "${TMP}" | __YOUR_PARSER__; }

		  If you DO pipe this command, it will echo its output for use on stdin to other commands.

		    { curl_env icanhazip.com | __YOUR_PARSER__; }

		OPTIONS::

		  To produce debug output..
		  
		    --debug
		    
		  Or set explicitely to a certain level..
		  
		    --debug=[0-9]

		  Or, use the debug environment variable..

		    export DEBUG_CURL_ENV=[0-9]

		  To view the curl help or manual, provide these options..
		
		    --curl_help

		    --curl_manual

		NOTES::
		
		  Only run a single call at a time. ( For now.. =] )

		EOF
		return 0
	}
	[ "${OPT_curl_help}" -eq 0 ] || { curl --help; return 0; }
	[ "${OPT_curl_manual}" -eq 0 ] || { curl --manual; return 0; }

	#
	WVARS=(
		http_code
		url_effective redirect_url
		http_connect
		time_total
		time_namelookup time_connect time_appconnect
		time_pretransfer time_redirect time_starttransfer
		size_download size_upload size_header size_request
		speed_download speed_upload
		content_type
		num_connects num_redirects
		ftp_entry_path ssl_verify_result
	)
	CHR_ESC="\\"
	CHR_DBQ="\""
	CHR_SGQ="'"
	RGX_TIME="^([0-9]{2,2}:[0-9]{2,2}:[0-9]{2,2}\.[0-9]+)"
	RGX_INFO="${RGX_TIME} == Info: (.*)"
	RGX_XMIT="${RGX_TIME} ([<=][=>]) (Send|Recv) (header|data), ([0-9]+).*"

	#
	CMD_RAW=(
		${ARGS[@]:+"${ARGS[@]}"}
	)

	for VAR in curl_env_{dbg,ext,hin,hdr,out,err,stt}
	do
		eval "${VAR}=()"
	done

	[ "${DBG:-0}" -lt 9 ] || echo 1>&2
	for ENT in "${CMD_RAW[@]}"
	do
		TMP=
		[ "${DBG:-0}" -lt 9 ] || \
		printf "{ %q }\n" "${ENT}" 1>&2
		printf -v ENT "%q" "${ENT}"
		CMD[${#CMD[@]}]="${ENT}"
		[[ "${ENT}" =~ \\ && ! "${ENT}" =~ ^"$'" ]] || \
		{ CMD_DBG[${#CMD_DBG[@]}]="${ENT}"; continue; }
		while [[ "${ENT}" =~ ([^\\]*)([\\])(.)(.*) ]]
		do
			TMP="${TMP}${BASH_REMATCH[1]}"
			[ "${BASH_REMATCH[3]}" != "'" ] || \
			TMP="${TMP}\\"
			TMP="${TMP}${BASH_REMATCH[3]}"
			ENT="${BASH_REMATCH[4]}"
			[ "${DBG:-0}" -lt 9 ] || \
			printf "( %s ) ( %s )\n" "${ENT}" "${TMP}" 1>&2
		done
		[ "${DBG:-0}" -lt 9 ] || \
		printf "{ %s }\n" "'${TMP}${ENT}'" 1>&2
		CMD_DBG[${#CMD_DBG[@]}]="'${TMP}${ENT}'"
	done

	[ "${DBG:-0}" -lt 9 ] || echo 1>&2
	[ "${DBG:-0}" -lt 1 ] || \
	echo "+ curl ${CMD_DBG[*]}" 1>&2
	[ "${DBG:-0}" -lt 8 ] || echo 1>&2

	TMP="$(
		IFS="${CRT}${NLN}"
		{ [ -t 0 ] && cat /dev/null || cat -; } |
		{
			eval curl \
				-w "\"$(
					printf \
						"CURL_ENV_STT:%s=%%{%s}\\\n" \
						$( for I in "${WVARS[@]}"; do echo "${I}"; echo "${I}"; done )
				)\"" \
				-o /dev/null \
				--trace-time \
				--trace - \
				"${CMD[@]}"
			echo "CURL_ENV_EXT:${?}"
		} |
		{
			while read -r ENT
			do
				[ -n "${ENT}" ] || continue
				if [[ "${ENT}" =~ ${RGX_XMIT} ]]
				then
					case "${BASH_REMATCH[3]}_${BASH_REMATCH[4]}" in
					( "Send_header" )	STG=curl_env_hin;;
					( "Send_data" )		STG=curl_env_inp;;
					( "Recv_header" )	STG=curl_env_hdr;;
					( "Recv_data" )		STG=curl_env_out;;
					esac
					CNT="${BASH_REMATCH[5]}"
					continue
				elif [[ "${ENT}" =~ ${RGX_INFO} ]]
				then
					STG=DBG
				elif [[ "${ENT}" =~ ^CURL_ENV_STT:(.*) ]]
				then
					STG=STT
				elif [[ "${ENT}" =~ ^CURL_ENV_EXT:(.*) ]]
				then
					STG=EXT
				fi
				[ "${DBG:-0}" -lt 8 ] || \
				printf "%s\t%s\t%q\n" "${STG}" "${CNT}" "${ENT}" 1>&2
				case "${STG}" in
				( DBG ) {
					echo "curl_env_dbg[0]=\"\${curl_env_dbg[0]}\${curl_env_dbg[0]:+\${NLN}}${BASH_REMATCH[2]}\""
				};;
				( EXT ) {
					echo "curl_env_ext[0]=\"\${curl_env_ext[0]}\${curl_env_ext[0]:+\${NLN}}${BASH_REMATCH[1]}\""
				};;
				( STT ) {
					echo "curl_env_stt[0]=\"\${curl_env_stt[0]}\${curl_env_stt[0]:+\${NLN}}${BASH_REMATCH[1]}\""
				};;
				( * ) {
					[[ "${ENT}" =~ ^[0-9]{4,4}:([ 0-9a-f]{48,48}) ]]
					[[ "${BASH_REMATCH[1]}" =~ ([ 0-9a-f]*[0-9a-f]) ]]
					TMP="${BASH_REMATCH[1]}"
					TMP="${STG}[0]=\"\${${STG}[0]}\"\$'${TMP// /\\x}'"
					#echo "${TMP}" 1>&2
					echo "${TMP}"
				};;
				esac
			done
		}
		IFS="${IFS_BAK:-$' \t\n'}"
	)"

	eval "${TMP}"

	curl_env_hdr[0]="${curl_env_hdr[0]//${CRT}${NLN}/${NLN}}"
	curl_env_hin[0]="${curl_env_hin[0]//${CRT}${NLN}/${NLN}}"
	[[ "${curl_env_hdr[0]}" =~ (.*[^${NLN}])[${NLN}]+$ ]] && curl_env_hdr[0]="${BASH_REMATCH[1]}"
	[[ "${curl_env_hin[0]}" =~ (.*[^${NLN}])[${NLN}]+$ ]] && curl_env_hin[0]="${BASH_REMATCH[1]}"

	[ "${DBG:-0}" -gt 7 ] || {
		[ "${DBG:-0}" -lt 4 ] || { echo; printf "* %s\n" "${curl_env_dbg[0]//${NLN}/${NLN}* }"; } 1>&2
		[ "${DBG:-0}" -lt 5 ] || { printf "! %s\n" "${curl_env_ext[0]//${NLN}/${NLN}! }"; } 1>&2
		[ "${DBG:-0}" -lt 6 ] || { echo; printf "= %s\n" "${curl_env_stt[0]//${NLN}/${NLN}= }"; } 1>&2
		[ "${DBG:-0}" -lt 3 ] \
		&& { TMP="${curl_env_hdr[0]%%${NLN}*}"; printf "%s\n" "${TMP:-ERR_NO_HEADERS}"; } 1>&2 \
		|| {
			echo; printf "> %s\n" "${curl_env_hin[0]//${NLN}/${NLN}> }"
			echo; printf "< %s\n" "${curl_env_hdr[0]//${NLN}/${NLN}< }"
		} 1>&2
		[ "${DBG:-0}" -lt 5 -o "${#curl_env_err[0]}" -eq 0 ] \
		|| { echo; printf "? %s\n" "${curl_env_err[0]//${NLN}/${NLN}? }"; } 1>&2
	}
	[ "${DBG:-0}" -lt 3 ] || { echo; } 1>&2
	[ "${DBG:-0}" -lt 2 -a -t 1 -a "${OPT_out}" -eq 0 ] || printf "%s" "${curl_env_out[0]}"

	return ${curl_env_ext[0]:-100}

}
